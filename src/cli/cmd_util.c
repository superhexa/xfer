#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <arpa/inet.h>
#include <unistd.h>
#include "core/runtime.h"
#include "cli/ui.h"
#include "cli/commands_decl.h"

int cmd_cfg(int argc, char **argv){ (void)argc;(void)argv; const sx_runtime_cfg_t *c=sx_runtime_cfg_get(); const char* auth = c->auth_token[0]?"set":"unset"; const char* cs = (c->cipher==2)?"chacha20":"aesgcm"; const char* ow = (c->overwrite_policy==0)?"skip":((c->overwrite_policy==2)?"force":"ask"); printf("Config: port=%u chunk=%u enc=%d comp=%d thr=%u str=%u auth=%s cipher=%s z=%d ver=%d io=%u ctmo=%u rty=%u ka=%d ow=%s pm=%d mt=%d log=%u\n", c->default_port, c->chunk_size, c->encryption_enabled, c->compression_enabled, c->throttle_kbps, c->streams, auth, cs, c->zlib_level, c->verify_enabled, c->io_timeout_ms, c->connect_timeout_ms, c->max_retries, c->keepalive_enabled, ow, c->preserve_mode, c->preserve_mtime, c->log_level); return 0; }
int cmd_hash(int argc, char **argv){ if(argc<2){ ui_usage("hash <file>"); return -1; } FILE *f=fopen(argv[1],"rb"); if(!f){perror("open");return -1;} unsigned char buf[8192]; size_t r; unsigned char acc=0; while((r=fread(buf,1,sizeof(buf),f))>0){ for(size_t i=0;i<r;i++) acc ^= buf[i]; } fclose(f); printf("xor8=%02x %s\n", acc, argv[1]); return 0; }
int cmd_ping(int argc, char **argv){ if(argc<3){ ui_usage("ping <host> <port>"); return -1; } int s; struct sockaddr_in a; memset(&a,0,sizeof(a)); a.sin_family=AF_INET; a.sin_port=htons((uint16_t)atoi(argv[2])); a.sin_addr.s_addr=inet_addr(argv[1]); s=socket(AF_INET,SOCK_STREAM,0); if(s<0){perror("socket");return -1;} int rc=connect(s,(struct sockaddr*)&a,sizeof(a)); if(rc==0) printf("ok\n"); else perror("connect"); close(s); return rc==0?0:-1; }

int cmd_help(int argc, char **argv){ (void)argc; (void)argv; help_header(); section_heading("Core Operations"); box_top(); help_line("xfer send <host> <port> <file>", "Send a file"); help_line("xfer recv <port> <outfile>", "Receive into file"); help_line("xfer serve <port> <out_dir>", "Server mode"); box_bottom(); section_heading("Security & Auth"); box_top(); help_line("encrypt <on|off>", "Toggle encryption"); help_line("cipher <aes|chacha>", "Select cipher"); help_line("verify <on|off>", "Integrity verify"); help_line("auth <token>", "Set auth token"); box_bottom(); section_heading("Performance & Tuning"); box_top(); help_line("compress <on|off>", "Toggle compression"); help_line("zlevel <0-9>", "Compression level"); help_line("chunk <bytes>", "Set chunk size"); help_line("throttle <kbps>", "Limit bandwidth"); help_line("streams <n>", "Parallel streams"); help_line("progress <mode>", "Progress style"); help_line("timeout <ms>", "I/O timeout"); help_line("ctmo <ms>", "Connect timeout"); help_line("retries <n>", "Retry count"); help_line("keepalive <on|off>", "TCP keepalive"); box_bottom(); section_heading("Filesystem & Preserve"); box_top(); help_line("overwrite <skip|ask|force>", "Overwrite policy"); help_line("preserve <mode|mtime|all|none>", "Preserve meta"); help_line("stat <file>", "File info"); help_line("ls [dir]", "List directory"); help_line("du [path]", "Disk usage bytes"); box_bottom(); section_heading("Tools & Utilities"); box_top(); help_line("cfg", "Show configuration"); help_line("hash <file>", "Quick XOR8 hash"); help_line("ping <host> <port>", "TCP reachability"); help_line("resume <host> <port> <file> <offset>", "Resume sending"); help_line("sendr <host> <port> <dir>", "Send dir (flat)"); help_line("sendg <host> <port> <pattern>", "Send glob matches"); help_line("sendp <host> <port> <pattern>", "Parallel send (WIP)"); help_line("loglevel <name|n>", "Set log level"); help_line("version", "Show version"); help_line("exit", "Quit"); box_bottom(); help_footer(); return 0; }
int cmd_version(int argc, char **argv){ (void)argc;(void)argv; printf("XFER v2\n"); return 0; }
int cmd_exit(int argc, char **argv) { (void)argc; (void)argv; exit(0); }
int cmd_loglevel(int argc, char **argv){ if(argc<2){ ui_usage("loglevel <debug|info|warn|error|fatal|n>"); return -1; } const char *v=argv[1]; uint32_t lvl; if(strcmp(v,"debug")==0) lvl=0; else if(strcmp(v,"info")==0) lvl=1; else if(strcmp(v,"warn")==0) lvl=2; else if(strcmp(v,"error")==0) lvl=3; else if(strcmp(v,"fatal")==0) lvl=4; else lvl=(uint32_t)strtoul(v,NULL,10); sx_runtime_cfg_set_loglevel(lvl); ui_ok("loglevel=%u", sx_runtime_cfg_get()->log_level); return 0; }